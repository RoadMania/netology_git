БОГАТОВ АЛЕКСЕЙ

1. Содержание
+ [05-virt-01-basics](#virt01); <br>
+ [05-virt-02-iaac](#virt02); <br>


<br> <br>
05-virt-05-docker-swarm<br>
<b>Задание 1. </b><br>
1) Для реплицируемой службы указывается количество идентичных задач, которые необходимо запустить.
Глобальная служба запускает одну задачу на каждом узле. Заранее заданного количества заданий нет. Каждый раз, когда добавляется узел в swarm, оркестратор создает задачу, а планировщик назначает задачу новому узлу.
2) Для выбора лидера используется алгоритм поддержания распределённого консенсуса - Raft.
Если обычный узел долго не получает сообщений от лидера, то он переходит в состояние «кандидат» и посылает другим узлам запрос на голосование. Другие узлы голосуют за того кандидата, от которого они получили первый запрос. Если кандидат получает сообщение от лидера, то он снимает свою кандидатуру и возвращается в обычное состояние. Если кандидат получает большинство голосов, то он становится лидером. Если же он не получил большинства (это случай, когда на кластере возникли сразу несколько кандидатов и голоса разделились), то кандидат ждёт случайное время и инициирует новую процедуру голосования.
Процедура голосования повторяется, пока не будет выбран лидер.
3) Overlay Network в контексте docker является распределенной сетью между несколькими узлами docker. Эта сеть находится поверх сети, специфичные для хоста, позволяя контейнерам, подключенным к ней, безопасно обмениваться данными при включенном шифровании. <br>
<br><b>Задание 2. </b>
<div> <img src="https://github.com/RoadMania/netology_git/blob/main/screens/docker_swarm.JPG"> </div> 
<br><b>Задание 3. </b> <br>
<div> <img src="https://github.com/RoadMania/netology_git/blob/main/screens/docker_cluster.JPG"> </div>
<br>
<br>
<br>
<br>
<br>
05-virt-04-docker-compose <br>
<b>Задание 1. </b><br>
<div> <img src="https://github.com/RoadMania/netology_git/blob/main/screens/packer_terminal.JPG"> </div>
<div> <img src="https://github.com/RoadMania/netology_git/blob/main/screens/packer.JPG"> </div>
<br><b>Задание 2. </b>
<br><b>Задание 3. </b> <br>
<br>
<br>
<br>
<br>
<br>
05-virt-03-docker <br>
<b>Задание 1. </b><br>
https://hub.docker.com/repository/docker/spencer98/netology_nginx <br>
<br><b>Задание 2. </b> <br>
<ul>
<li> Высоконагруженное монолитное java веб-приложение -  учитывая что приложение монолитное, его лучше разместить на физической машине. </li>
<li> Nodejs веб-приложение - контейнеризация, т.к. снижает трудозатраты на деплой приложения и организацию микросервисной архитектуры </li>
<li> Мобильное приложение c версиями для Android и iOS - физические сервера или фиртуальные, потому что нам нужно работать с интерфейлом, а контейнеризация не сможет этого предоставить. </li> 
<li> Шина данных на базе Apache Kafka -  брокеров лучше размещать на вирт. машинах </li>
 <li> Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;  -  некоторые функции подразумевают использование хостов, так что используем виртуальную машину, либо контейнер. </li>
 <li> Мониторинг-стек на базе Prometheus и Grafana; -  Для облегчения развётывания будем исползовать виртуальную машину или контейнер. </li>
 <li> MongoDB, как основное хранилище данных для java-приложения; -  можем воспользоваться всеми тремя вариантами. </li>
 <li> Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry -  Gitlab можем исползовать в любых трёх вариантах, а Docker Registry с самого начала поставляется в контейнере. </li>
</ul>
<br><b>Задание 3. </b> <br>
<div> <img src="https://github.com/RoadMania/netology_git/blob/main/screens/docker.JPG"> </div> 
<br>
<br>
<br>
<br>
<br>
<a name="virt02"></a> 05-virt-02-iaac <br>
<b>Задание 1. </b><br>
Основным преимуществом подхода IaaC является "быстрая и эффективная разработка", "Стабильность среды, устранение дрейфа конфигураций" и "Ускорение производства и вывода продукта на рынок". <b>Главным</b> преимуществом IaaC является идемпотентность. <br>
<br><b>Задание 2. </b> <br>
1)Порог входа в Ansible очень низкий, он прост и удобен. Плюсом является еще то, Ansible использует существующую SSH инфраструктуру, в то время как другие требуют установки специального PKI-окружения. <br> 2)Pull, потому что отсутствует единая точка отказа и хранения данных для доступа. <br>
<br><b>Задание 3. </b> <br>
<div> <img src="https://github.com/RoadMania/netology_git/blob/main/screens/VBox.JPG"> </div> 
<br> <br>
spenc@bogatov:~$ vagrant -v <br>
Vagrant 2.2.14<br>

 spenc@bogatov:~$ ansible --version <br>
ansible 2.10.8<br>
  config file = None<br>
  configured module search path = ['/home/spenc/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']<br>
  ansible python module location = /usr/lib/python3/dist-packages/ansible<br>
  executable location = /usr/bin/ansible<br>
  python version = 3.9.2 (default, Feb 28 2021, 17:03:44) [GCC 10.2.1 20210110]<br>
<br>
<br>
<br>
<br>
<br>
 <a name="virt01"></a> 05-virt-01-basics. <br>
<b>Задание 1. </b><br>
Виртруализация - процесс, полностью эмулирующий "компьютер", с процессором, памятью, набором железа, от видеокарты, до жестких дисков.
Паравиртуализация, почти тоже самое, что и в предыдущем случае, но некоторые компоненты, например сетевые или дисковые (и другие) устройства могут быть доступны напрямую через вызовы наружу виртуальной машины. 
Виртуализация на уровне операционной системы — метод виртуализации, при котором ядро операционной системы поддерживает несколько изолированных экземпляров пространства пользователя, вместо одного. <br><br>
<b>Задание 2. </b>
<ul>
<li> Высоконагруженная база данных, чувствительная к отказу - физические сервера. Не вижу смысла в виртуализации, особенно при условии чувствительности к отказам. </li>
<li> Различные web-приложения - Виртуализация на уровне операционной системы. Хороший шанс применить контейнеризацию. </li>
<li> Windows системы для использования бухгалтерским отделом - паравиртуализация. Думаю, при использовании бухгалтерских приложений этот вариант лучше всего подходит. Чтобы у каждого был доступ (а-ля терминальный сервер) </li>
<li> Системы, выполняющие высокопроизводительные расчеты на GPU - физические сервера. Опять же не вижу смысла в принципе иметь какую-то виртуализацию. Подобные системы даже не всегда требуют веб-интерфейс </li> </ul>
<b>Задание 3. </b> <br>
1) VMWare - Универсальное решение для наших ОС, выполняющих базовые\общие функции, не требующие спец. оборудование. <br>
2) Xen - бесплатный и кроссплатформенный. <br>
3) Снова Xen. Бесплатный и максимально совместимый (Если можно выбрать платный вариант - то лучше Hyper-v, так как еще больше совместим с Microsoft-стэк) <br>
4) KVM - для линукс систем оптимальное решение, либо VMWare для платного решения. <br> <br>
<b>Задание 4. </b> <br>
Требуется целый набор специалистов различного профиля, данный способ виртуализации инфраструктуры является дорогостоящим и неэффективным в долгосрочной перспективе, поскольку, по мере развития технологий, компании стремятся обеспечить легкость в управлении, совместимость различных систем и масштабируемость инфраструктуры. Есть сложности с переносом данных с физических серверов на виртуальные. <br> Для минимизации проблем, думаю, следует просто отказаться от подобного метода и использовать единую систему.
